ðŸ§© What is GraphQL?

GraphQL is a query language for APIs and a runtime for executing those queries using your existing data.
It was developed by Facebook (now Meta) in 2012 and released publicly in 2015.

---
ðŸ’¡ Core Idea

With GraphQL, the client (like a frontend app) can ask for exactly the data it needs â€” nothing more, nothing less.

This is very different from REST APIs, where each endpoint returns a fixed structure of data, even if you only need part of it.

---
ðŸ” Example Comparison

ðŸ§± REST API Example

Suppose you want to fetch a userâ€™s profile and their posts.

 You might have:

   `/users/1` â†’ returns user info
   `/users/1/posts` â†’ returns posts by that user

If you need both the userâ€™s name and their post titles, youâ€™d have to make two separate requests and handle extra unnecessary data.

âš¡ GraphQL Example

You can make one single query that asks for only what you need:

graphql
{
  user(id: 1) {
    name
    posts {
      title
    }
  }
}


âž¡ï¸ The response will include only the fields you requested:

json
{
  "data": {
    "user": {
      "name": "John Doe",
      "posts": [
        { "title": "My First Post" },
        { "title": "Learning GraphQL" }
      ]
    }
  }
}


So, the client controls the shape of the response, not the server.

---
âš™ï¸ GraphQL = Query + Runtime

 Query Language: Defines what data clients can request and how to request it.
 Runtime: Executes those queries by connecting them to your actual data sources (like databases, APIs, etc.).

---
ðŸ“¦ Why Use GraphQL?

âœ… Fetch multiple resources in a single request
âœ… Avoid over-fetching or under-fetching data
âœ… Strongly typed schema ensures predictable results
âœ… Easy to evolve APIs without breaking old clients

---
ðŸ§  In short:

GraphQL gives the client the power to decide what data it wants, and the server the responsibility to describe whatâ€™s available.

---

2. GraphQL Queries (Read Data)

 Queries are used to fetch data from the server.
 Think of them like GET requests in REST.

 Example:

graphql
query {
  user(id: 1) {
    name
    email
  }
}


âž¡ï¸ This asks the server for a user with `id: 1`, and only the `name` and `email` fields.

 Expected Response:

json
{
  "data": {
    "user": {
      "name": "Vamsi",
      "email": "vamsi@example.com"
    }
  }
}


---

 3. GraphQL Mutations (Write Data)

 Mutations are used to create, update, or delete data.
 Think of them like POST, PUT, or DELETE in REST.

 Example:

graphql

mutation {
  addUser(name: "Vamsi", email: "vamsi@example.com") {
    id
    name
  }
}


âž¡ï¸ Creates a new user and returns their `id` and `name`.

 Expected Response:

json
{
  "data": {
    "addUser": {
      "id": 1,
      "name": "Vamsi"
    }
  }
}


---

 4. GraphQL Subscriptions (Real-time Updates)

 Subscriptions are used for real-time communication.
 They use WebSockets to keep the connection open.
 The server sends updates automatically when data changes.

 Example:

graphql
subscription {
  userAdded {
    id
    name
  }
}


âž¡ï¸ Whenever a new user is added, the server pushes that data to all subscribed clients.

 Expected Real-time Response:

json
{
  "data": {
    "userAdded": {
      "id": 2,
      "name": "Kumar"
    }
  }
}


---

 5. GraphQL Schema (Blueprint)

 The schema defines the structure of your data â€” what queries, mutations, and subscriptions exist, and their types.
 Itâ€™s written in SDL (Schema Definition Language).

 Example:

graphql

type User {
  id: ID!
  name: String!
  email: String!
}

type Query {
  user(id: ID!): User
  users: [User]
}

type Mutation {
  addUser(name: String!, email: String!): User
}

type Subscription {
  userAdded: User
}


Here:

 `Query` â†’ read operations
 `Mutation` â†’ write operations
 `Subscription` â†’ real-time updates

---

 6. Validation

Before executing a query, GraphQL validates it to make sure:

 The query matches the schema.
 The requested fields exist.
 The field arguments match expected types.

Example of Invalid Query:

graphql
query {
  user(id: "abc") {
    age    âŒ if 'age' field doesnâ€™t exist in schema
  }
}


âž¡ï¸ GraphQL will respond with a validation error before executing.

---

 7. Execution

Once the query passes validation:

1. GraphQL looks up the resolver functions for each field.
2. Each resolver fetches or computes the data.
3. The results are combined and returned in JSON format.

---
Client Query
     â†“
Schema (defines available types & fields)
     â†“
Resolver (fetches actual data)
     â†“
GraphQL Execution Engine (organizes results)
     â†“
Response (in JSON)


 Example Flow (Complete Picture):

query:

graphql
query {
  user(id: 1) {
    name
    email
  }
}


schema:

graphql
type User {
  id: ID!
  name: String!
  email: String!
}

type Query {
  user(id: ID!): User
}


resolver (in JavaScript, for example):

js
const resolvers = {
  Query: {
    user: (_, { id }) => users.find(u => u.id === Number(id)),
  },
};


response:

json
{
  "data": {
    "user": {
      "name": "Vamsi",
      "email": "vamsi@example.com"
    }
  }
}


---

 Summary Table

| Concept          | Purpose                     | Example                      | Equivalent in REST   |
| ---------------- | --------------------------- | ---------------------------- | -------------------- |
| Query        | Fetch data                  | `query { users { name } }`   | GET                  |
| Mutation     | Modify data                 | `mutation { addUser(...) }`  | POST/PUT/DELETE      |
| Subscription | Real-time updates           | `subscription { userAdded }` | WebSocket            |
| Schema       | Define types & operations   | `type Query { user: User }`  | API contract         |
| Validation   | Check if query is valid     | Field/type check             | Input validation     |
| Execution    | Run resolvers & return data | Resolver logic               | Controller execution |

